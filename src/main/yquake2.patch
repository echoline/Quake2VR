diff --git a/src/backends/generic/misc.c b/src/backends/generic/misc.c
index fb660cc3..66a94dd3 100644
--- a/src/backends/generic/misc.c
+++ b/src/backends/generic/misc.c
@@ -56,6 +56,10 @@
 #define PATH_MAX 4096
 #endif
 
+#ifdef ANDROID
+extern char datadir[];
+#endif
+
 static void SetExecutablePath(char* exePath)
 {
 	// !!! this assumes that exePath can hold PATH_MAX chars !!!
@@ -73,6 +77,9 @@ static void SetExecutablePath(char* exePath)
 		exePath[0] = '\0';
 	}
 
+#elif defined(ANDROID)
+	sprintf(exePath, "%s/", datadir);
+
 #elif defined(__linux)
 
 	// all the platforms that have /proc/$pid/exe or similar that symlink the
diff --git a/src/backends/unix/main.c b/src/backends/unix/main.c
index 97b74a8a..de10fe01 100644
--- a/src/backends/unix/main.c
+++ b/src/backends/unix/main.c
@@ -39,10 +39,16 @@
 void registerHandler(void);
 
 int
+#ifdef ANDROID
+android_main(int argc, char **argv)
+#else
 main(int argc, char **argv)
+#endif
 {
+#ifndef ANDROID
 	// register signal handler
 	registerHandler();
+#endif
 
 	// Setup FPU if necessary
 	Sys_SetupFPU();
diff --git a/src/backends/unix/signalhandler.c b/src/backends/unix/signalhandler.c
index 1a72939d..00bbd00c 100644
--- a/src/backends/unix/signalhandler.c
+++ b/src/backends/unix/signalhandler.c
@@ -30,7 +30,7 @@
 
 #include "../../common/header/common.h"
 
-#if defined(HAVE_EXECINFO)
+#if 0 && defined(HAVE_EXECINFO)
 #include <execinfo.h>
 
 void
diff --git a/src/backends/unix/system.c b/src/backends/unix/system.c
index 9f241440..765df06b 100644
--- a/src/backends/unix/system.c
+++ b/src/backends/unix/system.c
@@ -47,6 +47,17 @@
 #include "../../common/header/common.h"
 #include "../../common/header/glob.h"
 
+#ifdef ANDROID
+#include <android/log.h>
+#include <android/dlext.h>
+#include <sys/mman.h>
+struct android_namespace_t* android_create_namespace(const char* name,
+                                                    const char* ld_library_path,
+                                                    const char* default_library_path,
+                                                    uint64_t type,
+                                                    const char* permitted_when_isolated_path);
+#endif
+
 // Pointer to game library
 static void *game_library;
 
@@ -78,8 +89,11 @@ Sys_Error(char *error, ...)
 	va_start(argptr, error);
 	vsnprintf(string, 1024, error, argptr);
 	va_end(argptr);
+#ifndef ANDROID
 	fprintf(stderr, "Error: %s\n", string);
-
+#else
+    __android_log_print(ANDROID_LOG_ERROR, "org.echoline.quake2vr", "Error: %s\n", string);
+#endif
 	exit(1);
 }
 
@@ -160,7 +174,11 @@ Sys_ConsoleInput(void)
 void
 Sys_ConsoleOutput(char *string)
 {
+#ifndef ANDROID
 	fputs(string, stdout);
+#else
+	__android_log_print(ANDROID_LOG_DEBUG, "org.echoline.quake2vr", "%s", string);
+#endif
 }
 
 /* ================================================================ */
@@ -334,10 +352,12 @@ Sys_FindClose(void)
 void
 Sys_UnloadGame(void)
 {
+#ifndef ANDROID
 	if (game_library)
 	{
 		dlclose(game_library);
 	}
+#endif
 
 	game_library = NULL;
 }
@@ -355,21 +375,48 @@ Sys_GetGameAPI(void *parms)
 #else
 	const char *gamename = "game.so";
 #endif
+    FILE *fp;
 
-	if (game_library)
+    if (game_library)
 	{
 		Com_Error(ERR_FATAL, "Sys_GetGameAPI without Sys_UnloadingGame");
 	}
 
-	Com_Printf("Loading library: %s\n", gamename);
+#ifdef ANDROID
+//#define LIBSIZE 1024*1024*2
+//	void* start = mmap(NULL, LIBSIZE, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+	android_dlextinfo extinfo;
+    extinfo.flags = 0;
+//	extinfo.flags = ANDROID_DLEXT_RESERVED_ADDRESS;
+//	extinfo.flags = ANDROID_DLEXT_USE_NAMESPACE;
+//	extinfo.library_namespace = android_create_namespace("private", NULL, "");
+//	extinfo.reserved_addr = start;
+//	extinfo.reserved_size = LIBSIZE;
+
+	gamename = Cvar_VariableString("game");
+	if (gamename[0] == '\0')
+		gamename = "game";
+    snprintf(name, MAX_OSPATH, "lib%s.so", gamename);
+	Com_Printf("Loading library: %s\n", name);
+//	game_library = android_dlopen_ext(name, RTLD_NOW | RTLD_GLOBAL, &extinfo);
+    game_library = dlopen(name, RTLD_NOW|RTLD_GLOBAL);
+    if (game_library == NULL) {
+		Com_Printf("failed: %s", dlerror());
+		gamename = "game";
+		snprintf(name, MAX_OSPATH, "lib%s.so", gamename);
+//		game_library = android_dlopen_ext(name, RTLD_NOW | RTLD_GLOBAL, &extinfo);
+		game_library = dlopen(name, RTLD_NOW|RTLD_GLOBAL);
+		Com_Printf("Loading library: %s\n", name);
+    }
+#else
+	Com_Printf("Loading library: %s\n", name);
+#endif
 
 	/* now run through the search paths */
 	path = NULL;
 
-	while (1)
+	while (game_library == NULL)
 	{
-		FILE *fp;
-
 		path = FS_NextPath(path);
 
 		if (!path)
@@ -377,7 +424,11 @@ Sys_GetGameAPI(void *parms)
 			return NULL;     /* couldn't find one anywhere */
 		}
 
+#ifndef ANDROID
 		snprintf(name, MAX_OSPATH, "%s/%s", path, gamename);
+#else
+		snprintf(name, MAX_OSPATH, "%s/lib%s.so", path, gamename);
+#endif
 
 		/* skip it if it just doesn't exist */
 		fp = fopen(name, "rb");
@@ -438,7 +489,7 @@ Sys_Mkdir(const char *path)
 	{
 		if (mkdir(path, 0755) != 0)
 		{
-			Com_Error(ERR_FATAL, "Couldn't create dir %s\n", path);
+			Com_Printf("Couldn't create dir %s\n", path);
 		}
 	}
 }
@@ -479,6 +530,10 @@ char *
 Sys_GetHomeDir(void)
 {
 	static char gdir[MAX_OSPATH];
+#ifdef ANDROID
+	snprintf(gdir, sizeof(gdir), "%s/", cfgdir);
+	return gdir;
+#endif
 	char *home;
 
 	home = getenv("HOME");
diff --git a/src/client/cl_input.c b/src/client/cl_input.c
index 32d0e613..edd1c290 100644
--- a/src/client/cl_input.c
+++ b/src/client/cl_input.c
@@ -33,6 +33,8 @@ cvar_t *cl_nodelta;
 unsigned frame_msec;
 unsigned old_sys_frame_time;
 
+float *GetHeadPose();
+
 /*
  * KEY BUTTONS
  *
@@ -423,6 +425,7 @@ CL_AdjustAngles(void)
 {
 	float speed;
 	float up, down;
+	float *headPose = GetHeadPose();
 
 	if (in_speed.state & 1)
 	{
@@ -436,21 +439,24 @@ CL_AdjustAngles(void)
 
 	if (!(in_strafe.state & 1))
 	{
-		cl.viewangles[YAW] -= speed * cl_yawspeed->value * CL_KeyState(&in_right);
-		cl.viewangles[YAW] += speed * cl_yawspeed->value * CL_KeyState(&in_left);
+		cl.dviewangles[YAW] -= speed * cl_yawspeed->value * CL_KeyState(&in_right);
+		cl.dviewangles[YAW] += speed * cl_yawspeed->value * CL_KeyState(&in_left);
 	}
 
 	if (in_klook.state & 1)
 	{
-		cl.viewangles[PITCH] -= speed * cl_pitchspeed->value * CL_KeyState(&in_forward);
-		cl.viewangles[PITCH] += speed * cl_pitchspeed->value * CL_KeyState(&in_back);
+		cl.dviewangles[PITCH] -= speed * cl_pitchspeed->value * CL_KeyState(&in_forward);
+		cl.dviewangles[PITCH] += speed * cl_pitchspeed->value * CL_KeyState(&in_back);
 	}
 
 	up = CL_KeyState(&in_lookup);
 	down = CL_KeyState(&in_lookdown);
 
-	cl.viewangles[PITCH] -= speed * cl_pitchspeed->value * up;
-	cl.viewangles[PITCH] += speed * cl_pitchspeed->value * down;
+	cl.dviewangles[PITCH] -= speed * cl_pitchspeed->value * up;
+	cl.dviewangles[PITCH] += speed * cl_pitchspeed->value * down;
+
+	cl.viewangles[PITCH] = cl.dviewangles[PITCH] + headPose[0] * 180.0 / M_PI;
+	cl.viewangles[YAW] = cl.dviewangles[YAW] + headPose[1] * 180.0 / M_PI;
 }
 
 /*
diff --git a/src/client/cl_main.c b/src/client/cl_main.c
index a548ce8a..edd54d04 100644
--- a/src/client/cl_main.c
+++ b/src/client/cl_main.c
@@ -518,7 +518,7 @@ CL_InitLocal(void)
 	cl_paused = Cvar_Get("paused", "0", 0);
 	cl_loadpaused = Cvar_Get("cl_loadpaused", "1", CVAR_ARCHIVE);
 
-	gl1_stereo = Cvar_Get( "gl1_stereo", "0", CVAR_ARCHIVE );
+	gl1_stereo = Cvar_Get( "gl1_stereo", "1", CVAR_ARCHIVE );
 	gl1_stereo_separation = Cvar_Get( "gl1_stereo_separation", "1", CVAR_ARCHIVE );
 	gl1_stereo_convergence = Cvar_Get( "gl1_stereo_convergence", "1.4", CVAR_ARCHIVE );
 
@@ -822,7 +822,18 @@ CL_Frame(int packetdelta, int renderdelta, int timedelta, qboolean packetframe,
 
 	if (renderframe)
 	{
+#ifndef ANDROID
 		VID_CheckChanges();
+#else
+		if (vid_fullscreen->modified) {
+			S_StopAllSounds();
+			cl.refresh_prepped = false;
+			cl.cinematicpalette_active = false;
+			cls.disable_screen = false;
+
+			vid_fullscreen->modified = false;
+		}
+#endif
 		CL_PredictMovement();
 
 		if (!cl.refresh_prepped && (cls.state == ca_active))
diff --git a/src/client/cl_screen.c b/src/client/cl_screen.c
index 00e9cd18..ea99f9a5 100644
--- a/src/client/cl_screen.c
+++ b/src/client/cl_screen.c
@@ -1521,18 +1521,18 @@ SCR_UpdateScreen(void)
 		return; /* not initialized yet */
 	}
 
-	if ( gl1_stereo->value )
+	//if ( gl1_stereo->value )
 	{
 		numframes = 2;
 		separation[0] = -gl1_stereo_separation->value / 2;
 		separation[1] = +gl1_stereo_separation->value / 2;
 	}
-	else
+	/*else
 	{
 		separation[0] = 0;
 		separation[1] = 0;
 		numframes = 1;
-	}
+	}*/
 
 	for (i = 0; i < numframes; i++)
 	{
diff --git a/src/client/header/client.h b/src/client/header/client.h
index 04471802..abbc0bb4 100644
--- a/src/client/header/client.h
+++ b/src/client/header/client.h
@@ -140,6 +140,7 @@ typedef struct
 	   tracked view angles to account for standing on rotating objects,
 	   and teleport direction changes */
 	vec3_t		viewangles;
+	vec3_t 		dviewangles;
 
 	int			time; /* this is the time value that the client is rendering at. always <= cls.realtime */
 	float		lerpfrac; /* between oldframe and frame */
diff --git a/src/client/input/sdl.c b/src/client/input/sdl.c
index f5fd4a2a..b624a26c 100644
--- a/src/client/input/sdl.c
+++ b/src/client/input/sdl.c
@@ -27,7 +27,7 @@
  * =======================================================================
  */
 
-#include <SDL2/SDL.h>
+#include <SDL.h>
 
 #include "header/input.h"
 #include "../../client/header/keyboard.h"
@@ -889,12 +889,12 @@ IN_Move(usercmd_t *cmd)
 		}
 		else
 		{
-			cl.viewangles[YAW] -= m_yaw->value * mouse_x;
+			cl.dviewangles[YAW] -= m_yaw->value * mouse_x;
 		}
 
 		if ((mlooking || freelook->value) && !(in_strafe.state & 1))
 		{
-			cl.viewangles[PITCH] += m_pitch->value * mouse_y;
+			cl.dviewangles[PITCH] += m_pitch->value * mouse_y;
 		}
 		else
 		{
@@ -914,12 +914,12 @@ IN_Move(usercmd_t *cmd)
 
 	if (joystick_yaw)
 	{
-		cl.viewangles[YAW] -= (m_yaw->value * joystick_yaw) * joyViewFactor;
+		cl.dviewangles[YAW] -= (m_yaw->value * joystick_yaw) * joyViewFactor;
 	}
 
 	if(joystick_pitch)
 	{
-		cl.viewangles[PITCH] += (m_pitch->value * joystick_pitch) * joyViewFactor;
+		cl.dviewangles[PITCH] += (m_pitch->value * joystick_pitch) * joyViewFactor;
 	}
 
 	if (joystick_forwardmove)
diff --git a/src/client/menu/menu.c b/src/client/menu/menu.c
index 270be5f7..0b90aba3 100644
--- a/src/client/menu/menu.c
+++ b/src/client/menu/menu.c
@@ -226,24 +226,28 @@ Key_GetMenuKey(int key)
 		case K_KP_UPARROW:
 		case K_UPARROW:
 		case K_HAT_UP:
+        case K_JOY12:
 			return K_UPARROW;
 
 		case K_TAB:
 		case K_KP_DOWNARROW:
 		case K_DOWNARROW:
 		case K_HAT_DOWN:
+        case K_JOY13:
 			return K_DOWNARROW;
 
 		case K_KP_LEFTARROW:
 		case K_LEFTARROW:
 		case K_HAT_LEFT:
 		case K_TRIG_LEFT:
+        case K_JOY14:
 			return K_LEFTARROW;
 
 		case K_KP_RIGHTARROW:
 		case K_RIGHTARROW:
 		case K_HAT_RIGHT:
 		case K_TRIG_RIGHT:
+        case K_JOY15:
 			return K_RIGHTARROW;
 
 		case K_MOUSE1:
@@ -263,10 +267,6 @@ Key_GetMenuKey(int key)
 		case K_JOY9:
 		case K_JOY10:
 		case K_JOY11:
-		case K_JOY12:
-		case K_JOY13:
-		case K_JOY14:
-		case K_JOY15:
 		case K_JOY16:
 		case K_JOY17:
 		case K_JOY18:
@@ -280,7 +280,6 @@ Key_GetMenuKey(int key)
 		case K_JOY26:
 		case K_JOY27:
 		case K_JOY28:
-		case K_JOY29:
 		case K_JOY30:
 		case K_JOY31:
 
@@ -290,6 +289,7 @@ Key_GetMenuKey(int key)
 
 		case K_ESCAPE:
 		case K_JOY_BACK:
+        case K_JOY29:
 			return K_ESCAPE;
 	}
 
@@ -978,6 +978,7 @@ static const char *
 Keys_MenuKey(int key)
 {
     menuaction_s *item = (menuaction_s *)Menu_ItemAtCursor(&s_keys_menu);
+    int key2 = Key_GetMenuKey(key);
 
     if (bind_grab)
     {
@@ -995,7 +996,7 @@ Keys_MenuKey(int key)
         return menu_out_sound;
     }
 
-    switch (key)
+    switch (key2)
     {
     case K_KP_ENTER:
     case K_ENTER:
@@ -4933,7 +4934,8 @@ M_Init(void)
 
     /* initialize the server address book cvars (adr0, adr1, ...)
      * so the entries are not lost if you don't open the address book */
-    for (int index = 0; index < NUM_ADDRESSBOOK_ENTRIES; index++)
+    Cvar_Get("adr0", "echoline.org", CVAR_ARCHIVE);
+    for (int index = 1; index < NUM_ADDRESSBOOK_ENTRIES; index++)
     {
         char buffer[20];
         Com_sprintf(buffer, sizeof(buffer), "adr%d", index);
diff --git a/src/client/menu/videomenu.c b/src/client/menu/videomenu.c
index bfabcea3..9ef23c53 100644
--- a/src/client/menu/videomenu.c
+++ b/src/client/menu/videomenu.c
@@ -579,8 +579,8 @@ VID_MenuInit(void)
 	s_apply_action.generic.y = (y += 10);
 	s_apply_action.generic.callback = ApplyChanges;
 
-	Menu_AddItem(&s_opengl_menu, (void *)&s_renderer_list);
-	Menu_AddItem(&s_opengl_menu, (void *)&s_mode_list);
+//	Menu_AddItem(&s_opengl_menu, (void *)&s_renderer_list);
+//	Menu_AddItem(&s_opengl_menu, (void *)&s_mode_list);
 
 	// only show this option if we have multiple displays
 	if (GLimp_GetNumVideoDisplays() > 1)
diff --git a/src/client/refresh/gl3/gl3_draw.c b/src/client/refresh/gl3/gl3_draw.c
index 48ea046f..09d491f8 100644
--- a/src/client/refresh/gl3/gl3_draw.c
+++ b/src/client/refresh/gl3/gl3_draw.c
@@ -33,6 +33,8 @@ gl3image_t *draw_chars;
 
 static GLuint vbo2D = 0, vao2D = 0, vao2Dcolor = 0; // vao2D is for textured rendering, vao2Dcolor for color-only
 
+void GL3_Draw_Reinit(void);
+
 void
 GL3_Draw_InitLocal(void)
 {
@@ -50,6 +52,12 @@ GL3_Draw_InitLocal(void)
 	glGenBuffers(1, &vbo2D);
 	GL3_BindVBO(vbo2D);
 
+	GL3_Draw_Reinit();
+}
+
+void
+GL3_Draw_Reinit(void)
+{
 	GL3_UseProgram(gl3state.si2D.shaderProgram);
 
 	glEnableVertexAttribArray(GL3_ATTRIB_POSITION);
@@ -300,6 +308,7 @@ GL3_Draw_Fill(int x, int y, int w, int h, int c)
 void
 GL3_Draw_Flash(const float color[4], float x, float y, float w, float h)
 {
+#ifndef ANDROID
 	int i=0;
 
 	GLfloat vBuf[8] = {
@@ -326,13 +335,44 @@ GL3_Draw_Flash(const float color[4], float x, float y, float w, float h)
 	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
 
 	glDisable(GL_BLEND);
+#endif
 }
 
 void
 GL3_Draw_FadeScreen(void)
 {
 	float color[4] = {0, 0, 0, 0.6f};
+#ifndef ANDROID
 	GL3_Draw_Flash(color, 0, 0, vid.width, vid.height);
+#else
+	int i=0;
+	int x = 0, y = 0, h = vid.height, w = vid.width;
+
+	GLfloat vBuf[8] = {
+			//  X,   Y
+			x,   y+h,
+			x,   y,
+			x+w, y+h,
+			x+w, y
+	};
+
+	glEnable(GL_BLEND);
+
+	for(i=0; i<4; ++i)  gl3state.uniCommonData.color.Elements[i] = color[i];
+
+	GL3_UpdateUBOCommon();
+
+	GL3_UseProgram(gl3state.si2Dcolor.shaderProgram);
+
+	GL3_BindVAO(vao2Dcolor);
+
+	GL3_BindVBO(vbo2D);
+	glBufferData(GL_ARRAY_BUFFER, sizeof(vBuf), vBuf, GL_STREAM_DRAW);
+
+	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
+
+	glDisable(GL_BLEND);
+#endif
 }
 
 void
diff --git a/src/client/refresh/gl3/gl3_image.c b/src/client/refresh/gl3/gl3_image.c
index f5dfc161..ad9cd0e6 100644
--- a/src/client/refresh/gl3/gl3_image.c
+++ b/src/client/refresh/gl3/gl3_image.c
@@ -96,7 +96,7 @@ GL3_TextureMode(char *string)
 			continue; /* those (by default: font and crosshairs) always only use GL_NEAREST */
 		}
 
-		GL3_SelectTMU(GL_TEXTURE0);
+		GL3_SelectTMU(GL_TEXTURE5);
 		GL3_Bind(glt->texnum);
 		if ((glt->type != it_pic) && (glt->type != it_sky)) /* mipmapped texture */
 		{
diff --git a/src/client/refresh/gl3/gl3_main.c b/src/client/refresh/gl3/gl3_main.c
index e1f63877..b6078087 100644
--- a/src/client/refresh/gl3/gl3_main.c
+++ b/src/client/refresh/gl3/gl3_main.c
@@ -38,6 +38,12 @@
 
 #define REF_VERSION "Yamagi Quake II OpenGL3 Refresher"
 
+//extern int deviceWidth, deviceHeight;
+qboolean righteye;
+GLuint framebuffer_;
+void SetTexture(unsigned int);
+void RenderEyeToDisplay(unsigned int);
+
 refimport_t ri;
 
 gl3config_t gl3config;
@@ -82,11 +88,15 @@ const hmm_mat4 gl3_identityMat4 = {{
 cvar_t *gl_msaa_samples;
 cvar_t *r_vsync;
 cvar_t *gl_retexturing;
+#ifndef ANDROID
 cvar_t *vid_fullscreen;
+#endif
 cvar_t *r_mode;
 cvar_t *r_customwidth;
 cvar_t *r_customheight;
+#ifndef ANDROID
 cvar_t *vid_gamma;
+#endif
 cvar_t *gl_anisotropic;
 cvar_t *gl_texturemode;
 cvar_t *gl_drawbuffer;
@@ -201,9 +211,9 @@ GL3_Register(void)
 	gl_msaa_samples = ri.Cvar_Get ( "r_msaa_samples", "0", CVAR_ARCHIVE );
 	gl_retexturing = ri.Cvar_Get("r_retexturing", "1", CVAR_ARCHIVE);
 	gl3_debugcontext = ri.Cvar_Get("gl3_debugcontext", "0", 0);
-	r_mode = ri.Cvar_Get("r_mode", "4", CVAR_ARCHIVE);
-	r_customwidth = ri.Cvar_Get("r_customwidth", "1024", CVAR_ARCHIVE);
-	r_customheight = ri.Cvar_Get("r_customheight", "768", CVAR_ARCHIVE);
+	r_mode = ri.Cvar_Get("r_mode", "-1", CVAR_ARCHIVE);
+	r_customwidth = ri.Cvar_Get("r_customwidth", "300", CVAR_ARCHIVE);
+	r_customheight = ri.Cvar_Get("r_customheight", "300", CVAR_ARCHIVE);
 	gl3_particle_size = ri.Cvar_Get("gl3_particle_size", "40", CVAR_ARCHIVE);
 	gl3_particle_fade_factor = ri.Cvar_Get("gl3_particle_fade_factor", "1.2", CVAR_ARCHIVE);
 	gl3_particle_square = ri.Cvar_Get("gl3_particle_square", "0", CVAR_ARCHIVE);
@@ -227,7 +237,7 @@ GL3_Register(void)
 	gl_anisotropic = ri.Cvar_Get("r_anisotropic", "0", CVAR_ARCHIVE);
 
 	vid_fullscreen = ri.Cvar_Get("vid_fullscreen", "0", CVAR_ARCHIVE);
-	vid_gamma = ri.Cvar_Get("vid_gamma", "1.2", CVAR_ARCHIVE);
+	vid_gamma = ri.Cvar_Get("vid_gamma", "1.9", CVAR_ARCHIVE);
 	gl3_intensity = ri.Cvar_Get("gl3_intensity", "1.5", CVAR_ARCHIVE);
 	gl3_intensity_2D = ri.Cvar_Get("gl3_intensity_2D", "1.5", CVAR_ARCHIVE);
 
@@ -366,69 +376,93 @@ SetMode_impl(int *pwidth, int *pheight, int mode, int fullscreen)
 }
 
 static qboolean
-GL3_SetMode(void)
-{
-	int err;
-	int fullscreen;
-
-	fullscreen = (int)vid_fullscreen->value;
-
-	vid_fullscreen->modified = false;
-	r_mode->modified = false;
-
-	/* a bit hackish approach to enable custom resolutions:
-	   Glimp_SetMode needs these values set for mode -1 */
-	vid.width = r_customwidth->value;
-	vid.height = r_customheight->value;
-
-	if ((err = SetMode_impl(&vid.width, &vid.height, r_mode->value, fullscreen)) == rserr_ok)
-	{
-		if (r_mode->value == -1)
-		{
-			gl3state.prev_mode = 4; /* safe default for custom mode */
-		}
-		else
-		{
-			gl3state.prev_mode = r_mode->value;
-		}
-	}
-	else
-	{
-		if (err == rserr_invalid_mode)
-		{
-			R_Printf(PRINT_ALL, "ref_gl3::GL3_SetMode() - invalid mode\n");
-
-			if (gl_msaa_samples->value != 0.0f)
-			{
-				R_Printf(PRINT_ALL, "gl_msaa_samples was %d - will try again with gl_msaa_samples = 0\n", (int)gl_msaa_samples->value);
-				ri.Cvar_SetValue("r_msaa_samples", 0.0f);
-				gl_msaa_samples->modified = false;
-
-				if ((err = SetMode_impl(&vid.width, &vid.height, r_mode->value, 0)) == rserr_ok)
-				{
-					return true;
-				}
-			}
-			if(r_mode->value == gl3state.prev_mode)
-			{
-				// trying again would result in a crash anyway, give up already
-				// (this would happen if your initing fails at all and your resolution already was 640x480)
-				return false;
-			}
-
-			ri.Cvar_SetValue("r_mode", gl3state.prev_mode);
-			r_mode->modified = false;
-		}
-
-		/* try setting it back to something safe */
-		if ((err = SetMode_impl(&vid.width, &vid.height, gl3state.prev_mode, 0)) != rserr_ok)
-		{
-			R_Printf(PRINT_ALL, "ref_gl3::GL3_SetMode() - could not revert to safe mode\n");
-			return false;
-		}
-	}
+GL3_SetMode(void) {
+    int err;
+    int fullscreen;
+
+    fullscreen = (int) vid_fullscreen->value;
+
+    vid_fullscreen->modified = false;
+    r_mode->modified = false;
+
+    /* a bit hackish approach to enable custom resolutions:
+       Glimp_SetMode needs these values set for mode -1 */
+    vid.width = 300; //r_customwidth->value;
+    vid.height = 300; //r_customheight->value;
+    r_mode->value = -1;
+
+    if ((err = SetMode_impl(&vid.width, &vid.height, r_mode->value, fullscreen)) == rserr_ok) {
+        if (r_mode->value == -1) {
+            gl3state.prev_mode = 4; /* safe default for custom mode */
+        } else {
+            gl3state.prev_mode = r_mode->value;
+        }
+    } else {
+        if (err == rserr_invalid_mode) {
+            R_Printf(PRINT_ALL, "ref_gl3::GL3_SetMode() - invalid mode\n");
+
+            if (gl_msaa_samples->value != 0.0f) {
+                R_Printf(PRINT_ALL, "gl_msaa_samples was %d - will try again with gl_msaa_samples = 0\n", (int) gl_msaa_samples->value);
+                ri.Cvar_SetValue("r_msaa_samples", 0.0f);
+                gl_msaa_samples->modified = false;
+
+                if ((err = SetMode_impl(&vid.width, &vid.height, r_mode->value, 0)) == rserr_ok) {
+                    return true;
+                }
+            }
+            if (r_mode->value == gl3state.prev_mode) {
+                // trying again would result in a crash anyway, give up already
+                // (this would happen if your initing fails at all and your resolution already was 640x480)
+                return false;
+            }
+
+            ri.Cvar_SetValue("r_mode", gl3state.prev_mode);
+            r_mode->modified = false;
+        }
+
+        /* try setting it back to something safe */
+        if ((err = SetMode_impl(&vid.width, &vid.height, gl3state.prev_mode, 0)) != rserr_ok) {
+            R_Printf(PRINT_ALL, "ref_gl3::GL3_SetMode() - could not revert to safe mode\n");
+            return false;
+        }
+    }
+
+    return true;
+}
 
-	return true;
+void CardboardSetup() {
+	GLuint texture_;
+	GLuint depthrenderbuffer;
+
+	GL3_SelectTMU(GL_TEXTURE0);
+
+	glGenTextures(1, &texture_);
+	glBindTexture(GL_TEXTURE_2D, texture_);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+//	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+//	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, 600, 300, 0, GL_RGB, GL_UNSIGNED_BYTE, 0);
+	if (glGetError() != GL_NO_ERROR)
+		Sys_Error("error 1");
+
+	SetTexture(texture_);
+
+	glGenRenderbuffers(1, &depthrenderbuffer);
+	glBindRenderbuffer(GL_RENDERBUFFER, depthrenderbuffer);
+	glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, 600, 300);
+	if (glGetError() != GL_NO_ERROR)
+		Sys_Error("error 2");
+
+	glGenFramebuffers(1, &framebuffer_);
+	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer_);
+	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture_, 0);
+	glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer);
+	if (glGetError() != GL_NO_ERROR)
+		Sys_Error("error 3");
+
+	if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
+		Sys_Error("framebuffer setup failed");
 }
 
 // only needed (and allowed!) if using OpenGL compatibility profile, it's not in 3.2 core
@@ -455,7 +489,7 @@ GL3_Init(void)
 
 	GL3_Register();
 
-	/* set our "safe" mode */
+    /* set our "safe" mode */
 	gl3state.prev_mode = 4;
 	//gl_state.stereo_mode = gl1_stereo->value;
 
@@ -477,18 +511,18 @@ GL3_Init(void)
 	R_Printf(PRINT_ALL, "\nOpenGL setting:\n");
 	GL3_Strings();
 
-	/*
-	if (gl_config.major_version < 3)
-	{
-		// if (gl_config.major_version == 3 && gl_config.minor_version < 2)
-		{
-			QGL_Shutdown();
-			R_Printf(PRINT_ALL, "Support for OpenGL 3.2 is not available\n");
+    /*
+    if (gl_config.major_version < 3)
+    {
+        // if (gl_config.major_version == 3 && gl_config.minor_version < 2)
+        {
+            QGL_Shutdown();
+            R_Printf(PRINT_ALL, "Support for OpenGL 3.2 is not available\n");
 
-			return false;
-		}
-	}
-	*/
+            return false;
+        }
+    }
+    */
 
 	R_Printf(PRINT_ALL, "\n\nProbing for OpenGL extensions:\n");
 
@@ -933,7 +967,10 @@ GL3_DrawParticles(void)
 
 		glDepthMask(GL_FALSE);
 		glEnable(GL_BLEND);
+
+#ifndef ANDROID
 		glEnable(GL_PROGRAM_POINT_SIZE);
+#endif
 
 		GL3_UseProgram(gl3state.siParticle.shaderProgram);
 
@@ -958,10 +995,11 @@ GL3_DrawParticles(void)
 		glBufferData(GL_ARRAY_BUFFER, sizeof(part_vtx)*numParticles, buf, GL_STREAM_DRAW);
 		glDrawArrays(GL_POINTS, 0, numParticles);
 
-
 		glDisable(GL_BLEND);
 		glDepthMask(GL_TRUE);
+#ifndef ANDROID
 		glDisable(GL_PROGRAM_POINT_SIZE);
+#endif
 	}
 }
 
@@ -1200,21 +1238,21 @@ GL3_SetGL2D(void)
 	int y = 0;
 	int h = vid.height;
 
-#if 0 // TODO: stereo
+#if 1 // TODO: stereo
 	/* set 2D virtual screen size */
-	qboolean drawing_left_eye = gl_state.camera_separation < 0;
-	qboolean stereo_split_tb = ((gl_state.stereo_mode == STEREO_SPLIT_VERTICAL) && gl_state.camera_separation);
-	qboolean stereo_split_lr = ((gl_state.stereo_mode == STEREO_SPLIT_HORIZONTAL) && gl_state.camera_separation);
+	qboolean drawing_left_eye = !righteye; //gl_state.camera_separation < 0;
+//	qboolean stereo_split_tb = ((gl_state.stereo_mode == STEREO_SPLIT_VERTICAL) && gl_state.camera_separation);
+//	qboolean stereo_split_lr = ((gl_state.stereo_mode == STEREO_SPLIT_HORIZONTAL) && gl_state.camera_separation);
 
-	if(stereo_split_lr) {
-		w =  w / 2;
+//	if(stereo_split_lr) {
+//		w =  w / 2;
 		x = drawing_left_eye ? 0 : w;
-	}
+//	}
 
-	if(stereo_split_tb) {
+/*	if(stereo_split_tb) {
 		h =  h / 2;
 		y = drawing_left_eye ? h : 0;
-	}
+	} */
 #endif // 0
 
 	glViewport(x, y, w, h);
@@ -1305,20 +1343,20 @@ SetupGL(void)
 	w = x2 - x;
 	h = y - y2;
 
-#if 0 // TODO: stereo stuff
-	qboolean drawing_left_eye = gl_state.camera_separation < 0;
-	qboolean stereo_split_tb = ((gl_state.stereo_mode == STEREO_SPLIT_VERTICAL) && gl_state.camera_separation);
+#if 1 // TODO: stereo stuff
+	qboolean drawing_left_eye = !righteye; //gl_state.camera_separation < 0;
+/*	qboolean stereo_split_tb = ((gl_state.stereo_mode == STEREO_SPLIT_VERTICAL) && gl_state.camera_separation);
 	qboolean stereo_split_lr = ((gl_state.stereo_mode == STEREO_SPLIT_HORIZONTAL) && gl_state.camera_separation);
 
-	if(stereo_split_lr) {
-		w = w / 2;
-		x = drawing_left_eye ? (x / 2) : (x + vid.width) / 2;
-	}
+	if(stereo_split_lr) { */
+//		w = w / 2;
+		x = drawing_left_eye ? (x / 2) : (x + vid.width*2) / 2;
+/*	}
 
 	if(stereo_split_tb) {
 		h = h / 2;
 		y2 = drawing_left_eye ? (y2 + vid.height) / 2 : (y2 / 2);
-	}
+	} */
 #endif // 0
 
 	glViewport(x, y2, w, h);
@@ -1664,7 +1702,9 @@ GL3_Clear(void)
 	gl3depthmax = 1;
 	glDepthFunc(GL_LEQUAL);
 
+#ifndef ANDROID
 	glDepthRange(gl3depthmin, gl3depthmax);
+#endif
 
 	if (gl_zfix->value)
 	{
@@ -1689,6 +1729,10 @@ GL3_Clear(void)
 void
 GL3_BeginFrame(float camera_separation)
 {
+	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer_);
+
+	righteye = camera_separation < 0.0? false: true;
+
 	/* change modes if necessary */
 	if (r_mode->modified)
 	{
@@ -1755,6 +1799,7 @@ GL3_BeginFrame(float camera_separation)
 
 	GL3_SetGL2D();
 
+#ifndef ANDROID
 	/* draw buffer stuff */
 	if (gl_drawbuffer->modified)
 	{
@@ -1773,6 +1818,7 @@ GL3_BeginFrame(float camera_separation)
 			}
 		}
 	}
+#endif
 
 	/* texturemode stuff */
 	if (gl_texturemode->modified || (gl3config.anisotropic && gl_anisotropic->modified))
@@ -1889,6 +1935,7 @@ void R_Printf(int level, const char* msg, ...)
 	va_end(argptr);
 }
 
+#ifndef ANDROID
 /*
  * this is only here so the functions in shared source files
  * (shared.c, rand.c, flash.c, mem.c/hunk.c) can link
@@ -1914,3 +1961,4 @@ Com_Printf(char *msg, ...)
 	ri.Com_VPrintf(PRINT_ALL, msg, argptr);
 	va_end(argptr);
 }
+#endif
diff --git a/src/client/refresh/gl3/gl3_mesh.c b/src/client/refresh/gl3/gl3_mesh.c
index 8b60f776..6351845b 100644
--- a/src/client/refresh/gl3/gl3_mesh.c
+++ b/src/client/refresh/gl3/gl3_mesh.c
@@ -800,12 +800,14 @@ GL3_DrawAliasModel(entity_t *entity)
 	/* locate the proper data */
 	c_alias_polys += paliashdr->num_tris;
 
+#ifndef ANDROID
 	/* draw all the triangles */
 	if (entity->flags & RF_DEPTHHACK)
 	{
 		/* hack the depth range to prevent view model from poking into walls */
 		glDepthRange(gl3depthmin, gl3depthmin + 0.3 * (gl3depthmax - gl3depthmin));
 	}
+#endif
 
 	if (entity->flags & RF_WEAPONMODEL)
 	{
@@ -921,10 +923,12 @@ GL3_DrawAliasModel(entity_t *entity)
 		glDisable(GL_BLEND);
 	}
 
+#ifndef ANDROID
 	if (entity->flags & RF_DEPTHHACK)
 	{
 		glDepthRange(gl3depthmin, gl3depthmax);
 	}
+#endif
 
 	if (gl_shadows->value && gl3config.stencil && !(entity->flags & (RF_TRANSLUCENT | RF_WEAPONMODEL | RF_NOSHADOW)))
 	{
diff --git a/src/client/refresh/gl3/gl3_misc.c b/src/client/refresh/gl3/gl3_misc.c
index e1e8684f..7faabcd6 100644
--- a/src/client/refresh/gl3/gl3_misc.c
+++ b/src/client/refresh/gl3/gl3_misc.c
@@ -41,7 +41,9 @@ GL3_SetDefaultState(void)
 	glDisable(GL_CULL_FACE);
 	glDisable(GL_BLEND);
 
+#ifndef ANDROID
 	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+#endif
 
 	// TODO: gl1_texturealphamode?
 	GL3_TextureMode(gl_texturemode->string);
@@ -78,7 +80,7 @@ void
 GL3_InitParticleTexture(void)
 {
 	int x, y;
-	byte data[8][8][4];
+	static byte data[8][8][4];
 
 	/* particle texture */
 	for (x = 0; x < 8; x++)
@@ -100,9 +102,9 @@ GL3_InitParticleTexture(void)
 	{
 		for (y = 0; y < 8; y++)
 		{
-			data[y][x][0] = dottexture[x & 3][y & 3] * 255;
+			data[y][x][0] = 255; //dottexture[x & 3][y & 3] * 255;
 			data[y][x][1] = 0;
-			data[y][x][2] = 0;
+			data[y][x][2] = 255;
 			data[y][x][3] = 255;
 		}
 	}
diff --git a/src/client/refresh/gl3/gl3_sdl.c b/src/client/refresh/gl3/gl3_sdl.c
index 4242c7e1..92a11ce3 100644
--- a/src/client/refresh/gl3/gl3_sdl.c
+++ b/src/client/refresh/gl3/gl3_sdl.c
@@ -29,12 +29,19 @@
 
 #include "header/local.h"
 
-#include <SDL2/SDL.h>
+#include <SDL.h>
 
 static SDL_Window* window = NULL;
 static SDL_GLContext context = NULL;
 static qboolean vsyncActive = false;
 
+extern GLuint framebuffer_;
+
+void RenderEyeToDisplay(unsigned int);
+extern int deviceWidth, deviceHeight;
+
+void GL3_Draw_Reinit();
+
 // --------
 
 enum {
@@ -107,7 +114,27 @@ void GL3_EndFrame(void)
 		gl3state.vbo3DcurOffset = 0;
 	}
 
+	RenderEyeToDisplay(0);
+/*	glBindFramebuffer(GL_READ_FRAMEBUFFER, framebuffer_);
+	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
+	glBlitFramebuffer(0, 0, 800, 400, 0, 0, deviceWidth, deviceHeight, GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT, GL_NEAREST);*/
 	SDL_GL_SwapWindow(window);
+
+	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer_);
+	gl3state.currenttmu = GL_TEXTURE0;
+	glActiveTexture(GL_TEXTURE0);
+	glBindTexture(GL_TEXTURE_2D, gl3state.currenttexture);
+	glUseProgram(gl3state.currentShaderProgram);
+	glBindVertexArray(gl3state.currentVAO);
+	glBindBuffer(GL_ARRAY_BUFFER, gl3state.currentVBO);
+	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, gl3state.currentEBO);
+	glBindBuffer(GL_UNIFORM_BUFFER, gl3state.currentUBO);
+
+	GL3_Draw_Reinit();
+
+	GLuint error;
+	while ((error = glGetError()) != GL_NO_ERROR)
+		Com_Printf("GL Error: %d\n", error);
 }
 
 /*
@@ -213,10 +240,10 @@ int GL3_PrepareForWindow(void)
 
 	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
 	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
-	SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
+//	SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
 
 	// Set GL context flags.
-	int contextFlags = SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG;
+/*	int contextFlags = SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG;
 
 	if (gl3_debugcontext && gl3_debugcontext->value)
 	{
@@ -226,7 +253,7 @@ int GL3_PrepareForWindow(void)
 	if (contextFlags != 0)
 	{
 		SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, contextFlags);
-	}
+	}*/
 
 	// Let's see if the driver supports MSAA.
 	int msaa_samples = 0;
diff --git a/src/client/refresh/gl3/gl3_shaders.c b/src/client/refresh/gl3/gl3_shaders.c
index bcf4fb08..7dc80fd3 100644
--- a/src/client/refresh/gl3/gl3_shaders.c
+++ b/src/client/refresh/gl3/gl3_shaders.c
@@ -163,7 +163,9 @@ CreateShaderProgram(int numShaders, const GLuint* shaders)
 
 // ############## shaders for 2D rendering (HUD, menus, console, videos, ..) #####################
 
-static const char* vertexSrc2D = MULTILINE_STRING(#version 150\n
+static const char* vertexSrc2D = MULTILINE_STRING(#version 300 es\n
+
+		precision mediump float;
 
 		in vec2 position; // GL3_ATTRIB_POSITION
 		in vec2 texCoord; // GL3_ATTRIB_TEXCOORD
@@ -183,7 +185,9 @@ static const char* vertexSrc2D = MULTILINE_STRING(#version 150\n
 		}
 );
 
-static const char* fragmentSrc2D = MULTILINE_STRING(#version 150\n
+static const char* fragmentSrc2D = MULTILINE_STRING(#version 300 es\n
+
+		precision mediump float;
 
 		in vec2 passTexCoord;
 
@@ -218,7 +222,9 @@ static const char* fragmentSrc2D = MULTILINE_STRING(#version 150\n
 );
 
 // 2D color only rendering, GL3_Draw_Fill(), GL3_Draw_FadeScreen()
-static const char* vertexSrc2Dcolor = MULTILINE_STRING(#version 150\n
+static const char* vertexSrc2Dcolor = MULTILINE_STRING(#version 300 es\n
+
+		precision mediump float;
 
 		in vec2 position; // GL3_ATTRIB_POSITION
 
@@ -230,13 +236,15 @@ static const char* vertexSrc2Dcolor = MULTILINE_STRING(#version 150\n
 
 		void main()
 		{
-			gl_Position = trans * vec4(position, 0.0, 1.0);
+			gl_Position = trans * vec4(position, 0.0f, 1.0f);
 		}
 );
 
-static const char* fragmentSrc2Dcolor = MULTILINE_STRING(#version 150\n
+static const char* fragmentSrc2Dcolor = MULTILINE_STRING(#version 300 es\n
 
 		// for UBO shared between all shaders (incl. 2D)
+		precision mediump float;
+
 		layout (std140) uniform uniCommon
 		{
 			float gamma;
@@ -258,7 +266,9 @@ static const char* fragmentSrc2Dcolor = MULTILINE_STRING(#version 150\n
 
 // ############## shaders for 3D rendering #####################
 
-static const char* vertexCommon3D = MULTILINE_STRING(#version 150\n
+static const char* vertexCommon3D = MULTILINE_STRING(#version 300 es\n
+
+		precision mediump float;
 
 		in vec3 position;   // GL3_ATTRIB_POSITION
 		in vec2 texCoord;   // GL3_ATTRIB_TEXCOORD
@@ -287,7 +297,9 @@ static const char* vertexCommon3D = MULTILINE_STRING(#version 150\n
 		};
 );
 
-static const char* fragmentCommon3D = MULTILINE_STRING(#version 150\n
+static const char* fragmentCommon3D = MULTILINE_STRING(#version 300 es\n
+
+		precision mediump float;
 
 		in vec2 passTexCoord;
 
@@ -377,7 +389,7 @@ static const char* vertexSrc3DlmFlow = MULTILINE_STRING(
 
 		void main()
 		{
-			passTexCoord = texCoord + vec2(scroll, 0);
+			passTexCoord = texCoord + vec2(scroll, 0.0);
 			passLMcoord = lmTexCoord;
 			vec4 worldCoord = transModel * vec4(position, 1.0);
 			passWorldCoord = worldCoord.xyz;
@@ -415,9 +427,9 @@ static const char* fragmentSrc3Dwater = MULTILINE_STRING(
 		void main()
 		{
 			vec2 tc = passTexCoord;
-			tc.s += sin( passTexCoord.t*0.125 + time ) * 4;
+			tc.s += sin( passTexCoord.t*0.125 + time ) * 4.0;
 			tc.s += scroll;
-			tc.t += sin( passTexCoord.s*0.125 + time ) * 4;
+			tc.t += sin( passTexCoord.s*0.125 + time ) * 4.0;
 			tc *= 1.0/64.0; // do this last
 
 			vec4 texel = texture(tex, tc);
@@ -492,7 +504,7 @@ static const char* fragmentSrc3Dlm = MULTILINE_STRING(
 
 					vec3 lightToPos = dynLights[i].lightOrigin - passWorldCoord;
 					float distLightToPos = length(lightToPos);
-					float fact = max(0, intens - distLightToPos - 52);
+					float fact = max(0.0, intens - distLightToPos - 52.0);
 
 					// move the light source a bit further above the surface
 					// => helps if the lightsource is so close to the surface (e.g. grenades, rockets)
@@ -501,7 +513,7 @@ static const char* fragmentSrc3Dlm = MULTILINE_STRING(
 					lightToPos += passNormal*32.0;
 
 					// also factor in angle between light and point on surface
-					fact *= max(0, dot(passNormal, normalize(lightToPos)));
+					fact *= max(0.0, dot(passNormal, normalize(lightToPos)));
 
 
 					lmTex.rgb += dynLights[i].lightColor.rgb * fact * (1.0/256.0);
@@ -512,7 +524,7 @@ static const char* fragmentSrc3Dlm = MULTILINE_STRING(
 			outColor = lmTex*texel;
 			outColor.rgb = pow(outColor.rgb, vec3(gamma)); // apply gamma correction to result
 
-			outColor.a = 1; // lightmaps aren't used with translucent surfaces
+			outColor.a = 1.0; // lightmaps aren't used with translucent surfaces
 		}
 );
 
diff --git a/src/client/refresh/gl3/header/local.h b/src/client/refresh/gl3/header/local.h
index 5ae4200a..9a0ac818 100644
--- a/src/client/refresh/gl3/header/local.h
+++ b/src/client/refresh/gl3/header/local.h
@@ -82,10 +82,10 @@ enum {
 };
 
 // TODO: do we need the following configurable?
-static const int gl3_solid_format = GL_RGB;
-static const int gl3_alpha_format = GL_RGBA;
-static const int gl3_tex_solid_format = GL_RGB;
-static const int gl3_tex_alpha_format = GL_RGBA;
+static const int gl3_solid_format = GL_RGBA8;
+static const int gl3_alpha_format = GL_RGBA8;
+static const int gl3_tex_solid_format = GL_RGBA8;
+static const int gl3_tex_alpha_format = GL_RGBA8;
 
 extern unsigned gl3_rawpalette[256];
 extern unsigned d_8to24table[256];
diff --git a/src/client/sound/sdl.c b/src/client/sound/sdl.c
index 0f33a0d1..2dd9ecbf 100644
--- a/src/client/sound/sdl.c
+++ b/src/client/sound/sdl.c
@@ -34,7 +34,7 @@
  */
 
 /* SDL includes */
-#include <SDL2/SDL.h>
+#include <SDL.h>
 
 /* Local includes */
 #include "../../client/header/client.h"
@@ -1324,6 +1324,8 @@ SDL_BackendInit(void)
 
 #ifdef _WIN32
 	s_sdldriver = (Cvar_Get("s_sdldriver", "directsound", CVAR_ARCHIVE));
+#elif ANDROID
+	s_sdldriver = (Cvar_Get("s_sdldriver", "android", CVAR_ARCHIVE));
 #elif __linux__
 	s_sdldriver = (Cvar_Get("s_sdldriver", "alsa", CVAR_ARCHIVE));
 #elif __APPLE__
diff --git a/src/client/sound/sound.c b/src/client/sound/sound.c
index 4fabb6a8..52747dc1 100644
--- a/src/client/sound/sound.c
+++ b/src/client/sound/sound.c
@@ -162,7 +162,7 @@ static qboolean
 S_IsSilencedMuzzleFlash(const wavinfo_t* info, const void* raw_data, const char* name)
 {
 	/* Skip the prefix. */
-	static const size_t base_sound_string_length = strlen("sound/");
+	static const size_t base_sound_string_length = 6; // strlen("sound/");
 	const char* base_name = name + base_sound_string_length;
 
 	/* Match to well-known muzzle flash sound names. */
diff --git a/src/client/vid/glimp_sdl.c b/src/client/vid/glimp_sdl.c
index 36cfbdcc..c349b6c4 100755
--- a/src/client/vid/glimp_sdl.c
+++ b/src/client/vid/glimp_sdl.c
@@ -30,8 +30,8 @@
 #include "../../common/header/common.h"
 #include "header/ref.h"
 
-#include <SDL2/SDL.h>
-#include <SDL2/SDL_video.h>
+#include <SDL.h>
+#include <SDL_video.h>
 
 int glimp_refreshRate = -1;
 
@@ -550,19 +550,19 @@ GLimp_InitGraphics(int fullscreen, int *pwidth, int *pheight)
 				SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 0);
 				SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 0);
 			}
-			else if (width != 640 || height != 480 || (flags & fs_flag))
+			else if (width != 300 || height != 300 || (flags & fs_flag))
 			{
 				Com_Printf("SDL SetVideoMode failed: %s\n", SDL_GetError());
-				Com_Printf("Reverting to windowed r_mode 4 (640x480).\n");
+				//Com_Printf("Reverting to windowed r_mode 4 (640x480).\n");
 
 				/* Try to recover */
-				Cvar_SetValue("r_mode", 4);
+				Cvar_SetValue("r_mode", -1);
 				Cvar_SetValue("vid_fullscreen", 0);
 				Cvar_SetValue("vid_rate", -1);
 
 				fullscreen = 0;
-				*pwidth = width = 640;
-				*pheight = height = 480;
+				*pwidth = width = 300;
+				*pheight = height = 300;
 				flags &= ~fs_flag;
 			}
 			else
diff --git a/src/client/vid/vid.c b/src/client/vid/vid.c
index e6da7d5b..077cc6c6 100644
--- a/src/client/vid/vid.c
+++ b/src/client/vid/vid.c
@@ -30,6 +30,9 @@
 #include "../../client/header/client.h"
 #include "../../client/header/keyboard.h"
 
+#ifdef ANDROID
+refexport_t GetRefAPI(refimport_t);
+#endif
 // --------
 
 // Screenshots
@@ -336,7 +339,9 @@ qboolean
 VID_LoadRenderer(void)
 {
 	refimport_t	ri;
+#ifndef ANDROID
 	GetRefAPI_t	GetRefAPI;
+#endif
 
 #ifdef __APPLE__
 	const char* lib_ext = "dylib";
@@ -356,6 +361,7 @@ VID_LoadRenderer(void)
 	// Log what we're doing.
 	Com_Printf("----- refresher initialization -----\n");
 
+#ifndef ANDROID
 	snprintf(reflib_name, sizeof(reflib_name), "ref_%s.%s", vid_renderer->string, lib_ext);
 	snprintf(reflib_path, sizeof(reflib_path), "%s%s", Sys_GetBinaryDir(), reflib_name);
 	Com_Printf("Loading library: %s\n", reflib_name);
@@ -371,6 +377,7 @@ VID_LoadRenderer(void)
 
 		return false;
 	}
+#endif
 
 	// Fill in the struct exported to the renderer.
 	// FIXME: Do we really need all these?
@@ -504,8 +511,13 @@ VID_CheckChanges(void)
  * Initializes the video stuff.
  */
 void
-VID_Init(void)
-{
+VID_Init(void) {
+#ifdef ANDROID
+	static qboolean loaded = false;
+	if (loaded)
+		return;
+	loaded = true;
+#endif
 	// Console variables
 	vid_gamma = Cvar_Get("vid_gamma", "1.0", CVAR_ARCHIVE);
 	vid_fullscreen = Cvar_Get("vid_fullscreen", "0", CVAR_ARCHIVE);
@@ -532,8 +544,10 @@ VID_Init(void)
 void
 VID_Shutdown(void)
 {
+#ifndef ANDROID
 	VID_ShutdownRenderer();
 	GLimp_Shutdown();
+#endif
 }
 
 // ----
diff --git a/src/common/frame.c b/src/common/frame.c
index 474ec5a2..ebdc248d 100644
--- a/src/common/frame.c
+++ b/src/common/frame.c
@@ -93,40 +93,40 @@ Qcommon_Buildstring(void)
 	versionString = va("Yamagi Quake II v%s", YQ2VERSION);
 	verLen = strlen(versionString);
 
-	printf("\n%s\n", versionString);
+	Com_Printf("\n%s\n", versionString);
 
 	for( i = 0; i < verLen; ++i)
 	{
-		printf("=");
+		Com_Printf("=");
 	}
 
-	printf("\n");
+	Com_Printf("\n");
 
 
 #ifndef DEDICATED_ONLY
-	printf("Client build options:\n");
+	Com_Printf("Client build options:\n");
 
 #ifdef USE_CURL
-	printf(" + cURL HTTP downloads\n");
+	Com_Printf(" + cURL HTTP downloads\n");
 #else
-	printf(" - cURL HTTP downloads\n");
+	Com_Printf(" - cURL HTTP downloads\n");
 #endif
 
 #ifdef USE_OPENAL
-	printf(" + OpenAL audio\n");
+	Com_Printf(" + OpenAL audio\n");
 #else
-	printf(" - OpenAL audio\n");
+	Com_Printf(" - OpenAL audio\n");
 #endif
 
 #ifdef SYSTEMWIDE
-	printf(" + Systemwide installation\n");
+	Com_Printf(" + Systemwide installation\n");
 #else
-	printf(" - Systemwide installation\n");
+	Com_Printf(" - Systemwide installation\n");
 #endif
 #endif
 
-	printf("Platform: %s\n", YQ2OSTYPE);
-	printf("Architecture: %s\n", YQ2ARCH);
+	Com_Printf("Platform: %s\n", YQ2OSTYPE);
+	Com_Printf("Architecture: %s\n", YQ2ARCH);
 }
 
 void
diff --git a/src/common/header/shared.h b/src/common/header/shared.h
index 74b5088a..74727e72 100644
--- a/src/common/header/shared.h
+++ b/src/common/header/shared.h
@@ -46,7 +46,10 @@
  #undef false
 #endif
 
-typedef enum {false, true}  qboolean;
+#define false 0
+#define true 1
+typedef int qboolean;
+
 typedef unsigned char byte;
 
 #ifndef NULL
